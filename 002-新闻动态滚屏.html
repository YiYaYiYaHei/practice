<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>新闻动态滚屏</title>
  <style>
    #container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 180px;
      padding: 14px 20px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 10px;
    }
    .wrap {
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }
    #box {
      position: relative;
      left: 0px;
      top: 0px;
      bottom: 20px;
      width: calc(100% - 40px);
      overflow: hidden;
    }
    #box > div {
      width: 100%;
      height: 30px;
      line-height: 30px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <p style="color: red; font-size: 18px; font-weight: bold; padding: 100px; text-align: center;">样式请参照本示例</p>

  <div id="container" onmouseover="mouseOverEvt()" onmouseout="mouseOutEvt()">
    <div class="wrap">
      <div id="box">
        <div style="color: red;">第一条 2021/12/20</div>
        <div>第二条 2021/12/20</div>
        <div>第三条 2021/12/20</div>
        <div>第四条 2021/12/20</div>
        <div>第五条 2021/12/20</div>
        <div>第六条 2021/12/20</div>
      </div>
    </div>
  </div>

  <script>
    /**
     * 计算偏移（类似新闻动态滚屏效果，也叫走马灯）
     * 为了让首尾无缝衔接，所以写了这个。轮播图也用了这个思想
     *
     * 样式特别注意：
     * 1、需要有三个div容器：#container确定容器位置和大小；.wrap添加padding；#box展示内容必须relation定位
     *
     * 实现思路：
     * 1、准备舞台（#container）：设置舞台尺寸和整体位置
     * 2、确定在舞台上表演的位置（.wrap）：设置padding，决定要在舞台的那个位置表演
     * 3、准备演员组（#box）：通过修改演员组的top值，来实现滚屏效果
     *
     * @param {String} wrapName 标签选择器（需要有三个div容器：#container确定容器位置和大小；.wrap添加padding；#box展示内容必须relation定位）
     * @param {String} boxName 标签选择器
     * @param {Number} step 步长
    */
    class CalculationDeviation {
      constructor(wrapName, boxName, step) {
        // 获取中间层容器
        this.oWrap = document.querySelector(wrapName);
        // 获取最里层容器
        this.oBox = document.querySelector(boxName);
        // 记录原始数据，供鼠标滑上、滑离使用
        this.originInner = this.oBox.innerHTML;
        // 每次修改top值的步长，是个定值
        this.step = step || 5;
        // 偏移量，记录top偏移的位置
        this.deviation = 0;
        this.timer = null;
        // 初始化操作
        this.initOpetator();
      }
      // 初始化操作
      initOpetator() {
        // 判断是否滚屏，如果一屏能放下，就不需要滚屏了
        const flag = this.isScroll();
        flag && this.setIntervalEvt();
      }
      // 判断是否滚屏
      isScroll() {
        return (this.oBox.getBoundingClientRect().height) > this.oWrap.clientHeight;
      }
      /**
       * 设置滚屏定时器
       * 为了实现首尾无缝衔接，有2个关键步骤
       * 1、需要拷贝一份内容 this.oBox.innerHTML += this.oBox.innerHTML;
       * 2、偏移量需要和#box的实际高度比较 this.deviation >= (this.oBox.getBoundingClientRect().height / 2)
      */
      setIntervalEvt() {
        // 拷贝一份内容，用作首尾无缝过渡
        this.oBox.innerHTML += this.oBox.innerHTML;
        this.timer = setInterval(() => {
          this.getTop();
          this.oBox.style.top = `-${this.deviation}px`;
        }, 800);
      }
      getTop() {
        this.deviation += this.step;
        // this.deviation >= (this.oBox.getBoundingClientRect().height / 2) 是关键，可以实现无缝衔接
        this.deviation = this.deviation >= (this.oBox.getBoundingClientRect().height / 2) ? 0 : this.deviation;
      }
      // 清除定时器
      clearIntervalEvt() {
        this.timer && clearInterval(this.timer);
        this.timer = null;
      }
      // 鼠标滑上事件
      mouseOverEvt(event) {
        const ev = event || window.event;
        ev.stopPropagation();
        this.clearIntervalEvt();
        // 防止滑上时鼠标滚动，导致数据抖动
        if (!this.oWrap.style.overflow || this.oWrap.style.overflow === 'hidden') {
          this.oWrap.scrollTop = this.oBox.offsetTop;
          this.oBox.style.top = 0;
        }
        // 显示原始数据
        this.oBox.innerHTML = this.originInner;
        this.oWrap.style.overflow = 'auto';
      }
      // 鼠标滑离事件
      mouseOutEvt(event) {
        const ev = event || window.event;
        ev.stopPropagation();
        // 滑离时，从滚动位置开始滚屏
        this.deviation = this.oWrap.scrollTop || 0;
        this.oWrap.style.overflow = 'hidden';
        this.initOpetator();
      }
    }
    window.onload = () => {
      const calcuationDeviation = new CalculationDeviation('.wrap', '#box');
      console.log(calcuationDeviation);
      mouseOverEvt = () => calcuationDeviation.mouseOverEvt();
      mouseOutEvt = () => calcuationDeviation.mouseOutEvt();
    }
  </script>
</body>
</html>